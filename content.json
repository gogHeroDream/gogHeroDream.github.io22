[{"title":"git 相关一 / sell命令","date":"2018-07-22T09:03:38.000Z","path":"2018/07/22/180722git1/","text":"git 系列一命令行概述 dos （windows） shell （Linux）：bash csh ksh 常用命令 pwd (Print Working Directory) 查看当前目录 cd (Change Directory) 切换目录，如 cd /etc ls (List) 查看当前目录下内容，如 ls -al mkdir (Make Directory) 创建目录，如 mkdir blog touch 创建文件，如 touch index.html cat 查看文件全部内容，如 cat index.html less 查看文件，如more /etc/passwd、less /etc/passwd rm (remove) 删除文件，如 rm index.html、rm -rf blog rmdir (Remove Directory) 删除文件夹，只能删除空文件夹，不常用 mv (move) 移动文件或重命名，如 mv index.html ./demo/index.html cp (copy) 复制文件，cp index.html ./demo/index.html tab 自动补全，连按两次会将所有匹配内容显示出来 > 和 &gt;&gt;重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加 | 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数。 grep 匹配内容，一般结合管道符使用 vi编辑器 linux操作系统标配，相当于windows下的记事本。 vi编辑器的三种模式 vi编辑器提供了3种模式，分别是命令模式、插入模式、底行模式，每种模式下用户所能进行的操作是不一样的。 3种模式的切换如下图所示： vi常用操作 a) 打开/创建文件， vi 文件路径 b) 底行模式 :w保存，:w filenme另存为 c) 底行模式 :q退出 d) 底行模式 :wq保存并退出 e) 底行模式 :e! 撤销更改，返回到上一次保存的状态 f) 底行模式 :q! 不保存强制退出 g) 底行模式 :set nu 设置行号 h) 命令模式 ZZ（大写）保存并退出 i) 命令模式 u辙销操作，可多次使用 j) 命令模式 dd删除当前行 k) 命令模式 yy复制当前行 l) 命令模式 p 粘贴内容 m) 命令模式 ctrl+f向前翻页 n) 命令模式 ctrl+b向后翻页 o) 命令模式 i进入编辑模式，当前光标处插入 p) 命令模式 a进入编辑模式，当前光标后插入 q) 命令模式 A进入编辑模式，光标移动到行尾 r) 命令模式 o进入编辑模式，当前行下面插入新行 s) 命令模式 O进入编辑模式，当前行上面插入新行 版本控制概述 本地版本控制 集中版本控制 分布式版本控制 git环境安装 window安装 下载地址，下载后和普通软件安装方式一样 linux安装 CentOS发行版：sudo yum install git Ubuntu发行版：sudo apt-get install git Mac安装 打开Terminal直接输入git命令，会自动提示，按提示引导安装即可 git工作原理git的三个工作区域 工作目录 暂存区域 本地仓库 git管理文件的4中状态 未追踪untraced 已暂存staged 已提交commited 已修改modified git工作流程-本地创建仓库 配置用户信息 初始化仓库 添加文件到暂存区 提交文件 查看文件状态 查看提交历史 撤销文件修改 恢复版本 git分支操作分支概述分支操作 创建分支 切换分支 合并分支 删除分支 Git命令 配置用户信息 全局配置，软件安装目录C:\\Program Files\\Git\\mingw64\\etc\\gitconfig 用户配置，用户名目录C:\\Users\\www.gitconfig 项目配置，项目目录 git config –global user.name zhangsan git config –global user.email “zhangsan@163.com“ 查看文件状态 git status 查看提交记录(按q键退出) git log 工作区添加到暂存区 git add 暂存区覆盖工作区内容 git checkout 暂存区提交到本地仓库 git commit -m ‘bug fixed’ 回滚特定版本 git reset –hard","tags":[{"name":"语法","slug":"语法","permalink":"http://spzhanqi.top/tags/语法/"},{"name":"git","slug":"git","permalink":"http://spzhanqi.top/tags/git/"}]},{"title":"git 相关二 / git基础命令","date":"2018-07-22T09:03:38.000Z","path":"2018/07/22/180722git2/","text":"git常用命令 配置用户信息 git config –global user.name 用户名 git config –global user.email 邮箱 初始化本地仓库 git init 初始化远程仓库 git init –bare 把工作目录文件添加到暂存区 git add 文件列表 git add * 把暂存区中文件添加到本地仓库 git commit -m 备注信息 git commit -a -m 备注信息 （-a只能提交已修改的文件，不能提交未跟踪文件） add的逆操作 git rm –cached 文件列表 回滚修改的内容 git checkout 文件列表 git checkout . (回滚所有的修改，慎重使用) 使用本地仓库的快照进行回滚 git reset –hard –soft –mixed (默认参数) 回滚最后一次提交 git reset –hard HEAD^ 回滚所有的工作目录和暂存区内容 git reset –hard HEAD 克隆远程仓库的项目 git clone 远程仓库地址 项目名称 拉取远程的分支 git pull 远程仓库地址 远程分支名称:本地分支名称 推送分支到远程仓库 git push 远程仓库地址 本地分支名称:远程分支名称 添加远程仓库别名 git remote add 别名 远程仓库地址 删除远程仓库别名 git remote remove 别名 查看远程仓库别名的详细信息 git remote show 别名 查看所有别名 git remote 分支操作 创建分支 git branch 分支名称 切换分支 git checkout 分支名称 创建并切换分支 git checkout -b 分支名称 删除本地分支 git branch -d 分支名称（如果没有被合并，无法删除） git branch -D 分支名称（强制删除） 查看本地分支 git branch 查看远程分支 git branch -r 查看所有分支 git branch -a 删除远程分支 git push 远程仓库地址 :远程分支名称 git push 远程仓库地址 –delete 远程分支名称 保存当前状态 git stash 恢复当前状态 git stash pop","tags":[{"name":"语法","slug":"语法","permalink":"http://spzhanqi.top/tags/语法/"},{"name":"git","slug":"git","permalink":"http://spzhanqi.top/tags/git/"}]},{"title":"git 相关三 / 远程仓库相关","date":"2018-07-22T09:03:38.000Z","path":"2018/07/22/180722git3/","text":"git-系列三分支远程登录 telnet 一种不加密的通信协议 ssh 一种协议，用来实现两台计算机之间的通信（具体就是实现远程登录） 使用密码登录 首先客户端向服务器发送一个请求 服务器接收到请求之后向客户度发送自己的公钥 客户端接收到公钥之后存储到指定目录（C:\\Users\\www.ssh） 客户端输入密码然后用公钥加密，再次发送请求 服务器接收到密文之后，使用自己的私钥揭秘然后验证通过，从而允许客户端登录 使用公钥和私钥登录 客户端先生成自己的公钥和私钥（ssh-keygen -t rsa） 把客户端的公钥传递给服务器，服务器使用该公钥给客户端授权 客户端直接就可以免密登录了 远程（共享）仓库 借助一个远程仓库，大家可以共享代码、历史版本等数据，实现团队成员之间代码同步。 远程仓库操作流程创建远程仓库 创建以.git结尾的目录mkdir repo.git 进入该目录cd repo.git 初始化共享仓库git init –bare 这样我们就建好了一个共享的仓库，但这时这个仓库是一个空的仓库，并且不允在这个仓库中进行任何修改。 向共享仓库推送内容 将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。 进入自己的项目跟目录 cd demo git push ../repo.git master 这样demo项目就进入到了共享仓库中 从共享仓库取出内容 新创建一个目录example（模拟另一个开发者） 进入该目录cd ./example git clone repo.git 通过repo.git共享仓库，我们轻松得到了一个demo的副本 基于克隆下来的项目进行修改 修改内容 提交内容 推送内容 这样便实现了代码的共享，但是，我们发现我们这个共享的仓库只是放到了本地的，其它人是没有办法从我们这个共享仓库共享内容的！！！，那么要想实现共享，我们可以把这个共享的仓库放到一台远程服务器上，问题不就解决了吗？ 远程仓库服务GitHub 如果我们熟悉服务器的话，我们完全可以将上述的步骤在我们的远程服务器上进行操作，然后再做一些登录权限的设置，就可非常完美的搭建一个共享服务器了。其实为了更好的管理我们的仓库，一些第三方机构开发出了Web版仓库管理程序，通过Web界面形式管理仓库。 GitHub概述GitHub基本使用 注册账号 创建共享仓库 GitHub地址格式 https:// 获取代码不需要密码 提交代码需要密码 git@ 需要将自己的公钥添加到GitHub上 获取与提交代码都不需要密码","tags":[{"name":"语法","slug":"语法","permalink":"http://spzhanqi.top/tags/语法/"},{"name":"git","slug":"git","permalink":"http://spzhanqi.top/tags/git/"}]},{"title":"git 相关四 / 远程仓库相关","date":"2018-07-22T09:03:38.000Z","path":"2018/07/22/180722git4/","text":"git-系列四分支远程登录 telnet 一种不加密的通信协议 ssh 一种协议，用来实现两台计算机之间的通信（具体就是实现远程登录） 使用密码登录 首先客户端向服务器发送一个请求 服务器接收到请求之后向客户度发送自己的公钥 客户端接收到公钥之后存储到指定目录（C:\\Users\\www.ssh） 客户端输入密码然后用公钥加密，再次发送请求 服务器接收到密文之后，使用自己的私钥揭秘然后验证通过，从而允许客户端登录 使用公钥和私钥登录 客户端先生成自己的公钥和私钥（ssh-keygen -t rsa） 把客户端的公钥传递给服务器，服务器使用该公钥给客户端授权 客户端直接就可以免密登录了 远程（共享）仓库 借助一个远程仓库，大家可以共享代码、历史版本等数据，实现团队成员之间代码同步。 远程仓库操作流程创建远程仓库 创建以.git结尾的目录mkdir repo.git 进入该目录cd repo.git 初始化共享仓库git init –bare 这样我们就建好了一个共享的仓库，但这时这个仓库是一个空的仓库，并且不允在这个仓库中进行任何修改。 向共享仓库推送内容 将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。 进入自己的项目跟目录 cd demo git push ../repo.git master 这样demo项目就进入到了共享仓库中 从共享仓库取出内容 新创建一个目录example（模拟另一个开发者） 进入该目录cd ./example git clone repo.git 通过repo.git共享仓库，我们轻松得到了一个demo的副本 基于克隆下来的项目进行修改 修改内容 提交内容 推送内容 这样便实现了代码的共享，但是，我们发现我们这个共享的仓库只是放到了本地的，其它人是没有办法从我们这个共享仓库共享内容的！！！，那么要想实现共享，我们可以把这个共享的仓库放到一台远程服务器上，问题不就解决了吗？ 远程仓库服务GitHub 如果我们熟悉服务器的话，我们完全可以将上述的步骤在我们的远程服务器上进行操作，然后再做一些登录权限的设置，就可非常完美的搭建一个共享服务器了。其实为了更好的管理我们的仓库，一些第三方机构开发出了Web版仓库管理程序，通过Web界面形式管理仓库。 GitHub概述GitHub基本使用 注册账号 创建共享仓库 GitHub地址格式 https:// 获取代码不需要密码 提交代码需要密码 git@ 需要将自己的公钥添加到GitHub上 获取与提交代码都不需要密码","tags":[{"name":"语法","slug":"语法","permalink":"http://spzhanqi.top/tags/语法/"},{"name":"git","slug":"git","permalink":"http://spzhanqi.top/tags/git/"}]},{"title":"session and cookie","date":"2018-07-22T09:03:38.000Z","path":"2018/07/22/180722session&&cookie/","text":"Session And Cookiesession和cookie分析 http协议是无状态的 但是实际情况我们需要维护客户端和服务器之间的状态 可以通过cookie和session解决这个问题 cookie基本操作 获取cookie 设置cookie cookie分类 会话cookie 持久cookie cookie常用属性 expires 有效期 path cookie路径 封装cookie操作方式 设置cookie 获取cookie 使用jQuery插件操作cookie 获取所有cookie 获取指定cookie 设置cookie 删除cookie5 session操作 session是服务器端技术 session在开启的时候会生成一个唯一编号PHPSESSID session里面可以存储数据（这些数据与PHPSESSID相关联） cookie与session的关系 session可以借助cookie 但是cookie可以被浏览器禁用 可以通过别的办法解决：URL重写 模块化开发概念 非模块化开发缺点 命名冲突(EXTJS YUI EXJ.panel.abc()) 文件依赖 模板规范 浏览器端模块化 AMD — Require.js CMD — Sea.js 服务器端的模块化 CommonJS — Node.js requirejs基本使用模块定义与加载git初始化仓库完善登录功能模块化重构登录功能","tags":[{"name":"语法","slug":"语法","permalink":"http://spzhanqi.top/tags/语法/"},{"name":"git","slug":"git","permalink":"http://spzhanqi.top/tags/git/"}]},{"title":"JS距离相关的属性","date":"2018-04-03T09:03:38.000Z","path":"2018/04/03/180403js距离相关/","text":"理解不够，先上张图来凑js中获取各种宽度和距离，常常让我们混淆，各种浏览器的不兼容让我们很头疼，现在就在说说js中有哪些宽度和距离。 属性图解 名词解释 screen：屏幕。这一类取到的是关于屏幕的宽度和距离，与浏览器无关，应该是获取window对象的属性。client：使用区、客户区。指的是客户区，当然是指浏览器区域。offset：偏移。指的是目标甲相对目标乙的距离。scroll：卷轴、卷动。指的是包含滚动条的的属性。inner：内部。指的是内部部分，不含滚动条。avail：可用的。可用区域，不含滚动条，易与inner混淆。 window1.window.innerWidth/innerHeight描述：浏览器可见区域的内宽度、高度（不含浏览器的边框，但包含滚动条）。兼容：ie9/10、chrome、firefox。示例（缩放浏览器的宽度为1000px，高度为500px）： alert(window.innerWidth);// chrome/firefox/ie9/10=&gt;1000// ie6/7/8=&gt;undefinedalert(window.innerHeight);// chrome/firefox/ie9/10=&gt;500// ie6/7/8=&gt;undefined 2.window.outerWidth/outerHeight描述：浏览器外宽度（包含浏览器的边框，因各个浏览器的边框边一样，得到的值也是不一样的）。兼容：ie9/10、chrome、firefox。示例（缩放浏览器的宽度为1000px，高度为500px）： alert(window.outerWidth);// chrome/firefox/ie9/10=&gt;1002// ie6/7/8=&gt;undefinedalert(window.outerHeight);// chrome/firefox/ie9/10=&gt;502// ie6/7/8=&gt;undefined 注意：没有window.width属性。 3.window.screenLeft/screenTop描述：浏览器的位移，表示：ie浏览器的内边缘距离屏幕边缘的距离。chrome浏览器的外边缘距离屏幕边缘的距离。如图： 属性图解2 兼容：ie6/7/8/9/10、chrome。示例： alert(window.screenLeft);// ie=&gt;87// chrome=&gt;86// firefox=&gt;undefinedalert(window.screenTop);// ie=&gt;87// chrome=&gt;86// firefox=&gt;undefined 4.window.screenX/screenY描述：浏览器的位移，表示：ie9/10浏览器的外边缘距离屏幕边缘的距离。chrome浏览器的外边缘距离屏幕边缘的距离。由此可知，chrome的screenLeft和screenX是相等的（其目的是为了兼容ie和firefox，两个属性都兼备了，但更趋向于firefox，chrome的这种做法不止这一处，还有很多，其实这种做法便于开发者移植，但对开发者的开发过程产生了一定的混淆），ie9/10的screenLeft是大于screenX的.兼容：ie9/10、chrome、firefox。示例： alert(window.screenX);// chrome/firefox=&gt;86// ie9/10=&gt;79// ie6/7/8=&gt;undefined alert(window.screenY);// chrome/firefox=&gt;86// ie9/10=&gt;79// ie6/7/8=&gt;undefined 5.window.pageXOffset/pageYOffset描述：表示浏览器X轴（水平）、Y轴（垂直）滚动条的偏移距离。兼容：ie9/10、chrome、firefox。示例： document.onclick=function(){ alert(window.pageXOffset); // chrome=&gt;200 // firefox=&gt;200 // ie9/10=&gt;200 // ie6/7/8=&gt;undefined alert(window.pageYOffset); // chrome=&gt;200 // firefox=&gt;200 // ie9/10=&gt;200 // ie6/7/8=&gt;undefined}; 6.window.scrollX/scrollY描述：表示浏览器X轴（水平）、Y轴（垂直）滚动条的偏移距离。由此可知，在chrome和firefox中window.pageXOffset和window.scrollX是相等的，具体为什么会出现两个相等的属性值，不得而知。兼容：chrome、firefox。示例： document.onclick=function(){ alert(window.scrollX); // chrome=&gt;200 // firefox=&gt;200 // ie6/7/8/9/10=&gt;undefined alert(window.scrollY); // chrome=&gt;200 // firefox=&gt;200 // ie6/7/8/9/10=&gt;undefined}; screen1.screen.width/height描述：屏幕的宽度、高度（指的是屏幕的分辨率，单位为像素）。兼容性：ie6/7/8/9/10、chrome、firefox。示例（屏幕的分辨率为1440×900）： alert(screen.width);// chrome/firefox/ie6/7/8/9/10=&gt;1440alert(screen.height);// chrome/firefox/ie6/7/8/9/10=&gt;900 注意：此处必须是screen.width，而不是screenWidth，与接下来要说的各种宽度有所区别。 2.screen.availWidth/availHeight描述：屏幕的可用宽度、高度（通常与屏幕的宽度、高度一致）。兼容性：ie6/7/8/9/10、chrome、firefox。示例： alert(screen.availWidth);// chrome/firefox/ie6/7/8/9/10=&gt;1440alert(screen.availHeight);// chrome/firefox/ie6/7/8/9/10=&gt;900 element元素的宽度、位移、距离以元素的盒模型为content-box为例。即： box-sizing: content-box;其他盒模型计算会有差异，请勿对号入座。 1.elment.clientWidth/clientHeight描述：计算如下， 有滚动条时：clientWidth=元素左内边距宽度+元素宽度+元素右内边距宽度-元素垂直滚动条宽度无滚动条时：clientWidth=元素左内边距宽度+元素宽度+元素右内边距宽度 使用该特性可以计算出的滚动条宽度（即设置元素的内容宽度超过元素宽度，然后分别设置是否超过隐藏，两次的clientWidth差值就是滚动条的宽度）。兼容：chrome、firefox、ie6/7/8/9/10。示例（宽度和高度都为100px，边框为50px，内边距为60px，外边距为70px，左、上位移为80px，滚动条的宽度因系统不同而不同）： 属性图解3 // 有滚动条=&gt;paddingLeftWidth+width+paddingRightWidth-scrollYWidth// 无滚动条=&gt;paddingLeftWidth+width+paddingRightWidthalert(oDemo.clientWidth);// 有滚动条=&gt;60+100+60-17=203// 无滚动条=&gt;60+100+60=220// 有滚动条=&gt;paddingTopWidth+height+paddingBottomWidth-scrollYHeight// 无滚动条=&gt;paddingTopWidth+height+paddingBottomWidthalert(oDemo.clientHeight);// 有滚动条=&gt;60+100+60-17=203// 无滚动条=&gt;60+100+60=220 2.element.clientLeft/clientTop描述：clientLeft为左边框宽度，clientTop为上边框宽度。兼容：chrome、firefox、ie6/7/8/9/10。示例（宽度和高度都为100px，边框为50px，内边距为60px，外边距为70px，左、上位移为80px，滚动条的宽度因系统不同而不同）： 属性图解4 // borderLeftWidthalert(oDemo.clientLeft);// =&gt;50 // borderTopWidthalert(oDemo.clientTop);// =&gt;50 3.element.offsetWidth/offsetHeight描述：offsetWidth=元素左边框宽度+元素左内边距宽度+元素宽度+元素右内边距宽度+元素右边框宽度。兼容：chrome、firefox、ie6/7/8/9/10。示例（宽度和高度都为100px，边框为50px，内边距为60px，外边距为70px，左、上位移为80px，滚动条的宽度因系统不同而不同）： // borderLeftWidth+paddingLeftWidth+width+paddingRightWidth+borderRightWidthalert(oDemo.offsetWidth);// =&gt;50+60+100+60+50=320 // borderTopWidth+paddingLeftWidth+width+paddingRightWidth+borderRightWidthalert(oDemo.offsetWidth);// =&gt;50+60+100+60+50=320 4.element.offsetLeft/offsetTop描述：表示该元素相对于最近的定位祖先元素的距离，chrome：offsetLeft=定位祖先左边框宽度+定位祖先元素左内边距宽度+左位移+左外边距宽度ie6/7/8/9/10、firefox：offsetLeft=定位祖先元素左内边距宽度+左位移+左外边距宽度。chrome比其他浏览器多计算了定位祖先元素的边框。offsetTop同理。兼容：chrome、firefox、ie6/7/8/9/10。示例（宽度和高度都为100px，边框为50px，内边距为60px，外边距为70px，左、上位移为80px，滚动条的宽度因系统不同而不同）： // 以最近的定位祖先元素为准// 谷歌=&gt;parentBorderLeftWidth+parentPaddingLeftWidth+left+marginLeft// 其他=&gt;parentPaddingLeftWidth+left+marginLeftalert(oDemo.offsetLeft);// chrome=&gt;20+10+80+70=180// ie6/7/8/9/10/firefox=&gt;160 // 以最近的定位祖先元素为准// 谷歌=&gt;parentBorderTopWidth+parentPaddingTopWidth+left+marginLeft// 其他=&gt;parentBorderTopWidth+left+marginLeftalert(oDemo.offsetLeft);// chrome=&gt;20+10+80+70=180// ie6/7/8/9/10/firefox=&gt;160 5.element.scrollWidth/scrollHeight描述：计算方法如，有滚动条时： chrome、firefox、ie8/9/10：左内边距宽度+内容宽度。ie6/7：左内边距宽度+内容宽度+右内边距宽度（是由CSS的BUG引起）。无滚动条时：左内边距宽度+宽度+右内边距宽度。 兼容：chrome、firefox、ie8/9/10、ie6/7（半兼容）。示例（宽度和高度都为100px，边框为50px，内边距为60px，外边距为70px，左、上位移为80px，滚动条的宽度因系统不同而不同，内容宽度和高度都为200px）： // 有滚动条=paddingLeftWidth+contentWidth// 有滚动条(ie6/7)=paddingLeftWidth+contentWidth+paddingRightWidth// 无滚动条=paddingLeftWidth+width+paddingRightWidthalert(oDemo.scrollWidth);// 有滚动条=&gt;200+60=260// 有滚动条(ie6/7)=&gt;200+60+60=320// 无滚动条=&gt;100+60+60=220 // 有滚动条=paddingTopWidth+contentWidth// 有滚动条(ie6/7)=paddingTopWidth+contentWidth+paddingBottomWidth// 无滚动条=paddingTopWidth+width+paddingBottomWidthalert(oDemo.scrollHeight);// 有滚动条=&gt;60+200=260// 有滚动条(ie6/7)=&gt;60+200+60=320// 无滚动条=&gt;60+100+60=220 6.element.scrollLeft/scrollTop描述：获得水平、垂直滚动条的距离。兼容：chrome、firefox、ie6/7/8/9/10。示例（宽度和高度都为100px，边框为50px，内边距为60px，外边距为70px，左、上位移为80px，滚动条的宽度因系统不同而不同）： document.onclick=function(){ // 水平滚动条左距离 alert(oDemo.scrollLeft); // 垂直滚动条上距离 alert(oDemo.scrollTop);} 总结因为document.documentElement就是浏览器的html标签，所以获取浏览器的相关属性，也可以用该对象来获取。屏幕宽度：window.screen.width。浏览器内宽度：window.innerWidth || document.documentElement.clientWidth。元素内容宽度：element.clientWidth。元素占位宽度：element.offsetWidth。元素相对位置：无。原文来自:http://caibaojian.com/js-name.html","tags":[{"name":"JS基础语法","slug":"JS基础语法","permalink":"http://spzhanqi.top/tags/JS基础语法/"}]},{"title":"markdown语法","date":"2018-03-24T17:31:38.000Z","path":"2018/03/25/markdown语法/","text":"参考网址：http://wowubuntu.com/markdown/1、标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。①atx 形式 #与文字中间要有空格 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题②Setext 形式 用底线的形式，任何数量的 = 和 - 都可以有效果。2、图片！[提示的文字](图片链接地址)3、链接（两种）①内联：[显示的文字](链接地址)；②引用方式： 4、换行两个以上的空格然后回车5、代码引用如果引用的语句只有一段，不分行，可以用 将语句包起来。如code; 如果引用的语句为多行，可以将``置于这段代码的首行和末行。或者四个空格或一个制表符6、列表 7、引用> 和文本之间要保留一个字符的空格。 8、分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。9、字体属性通过闭合标签font，属性face为字体类型，color为字体颜色，size为字体大小 我是华文彩云color=graycolor=#0099ff size=5 face=”黑体”","tags":[{"name":"语法","slug":"语法","permalink":"http://spzhanqi.top/tags/语法/"}]},{"title":"建站日志","date":"2018-03-24T09:31:38.000Z","path":"2018/03/24/180324建站日志/","text":"写在前面本站于2018年3月20日创建，故在此mark，站点是本人用来及记录一些开发技巧与自我提升的一个记录依据，写的不好的地方希望各位路过的大神来补充一下。在此感谢！！！ 建站目的本站是利用hexo+github来搭建的个人博客站，从零开始建站，自身学会了一些技巧，对于自身来说是一件很有意义的事，在这里就分享下我的建站心得吧。 建站方式 首先你要是想拥有自己的站点有三种方式，如果只是写写博客推荐第3条而且免费， 1.申请域名、服务器（这个是真正属于自己的站点，想丢啥丢啥，不过别违法哦）；2.挂载到公司测试服务器上，（极度不推荐，可维护性差，代码说没就没了）；3.挂载到github上（极其推荐，免费、实用）。 使用第三种方式，快速建站又分为两种方式本站是第一种 1.hexo+github;2.Jekyll+github; 建站历程1.先申请账号要拥有自己的站点得先拥有自己的代码仓库，不然没有代码存放的地方怎么能拿出来看呢？账号可以去官网申请github官网 github_step1 按顺序都填完，邮箱认证完，点击右上角的新建一个仓库，新建一个仓库已自己仓库名.github.io来为这个仓库命名 github_step1 2.安装node环境依赖，去node官网下载稳定版; github_step1 3.安装hexo和hexocli打开命令行输入 npm i hexo -gnpm i hexocli -g 输入 hexo -v 有版本号返回说明安装成功 4.建立基站找一个存放hexo代码的blog文件夹在该目录下输入 hexo init 初始化该文件夹； 5.尝试新建一个日志在命令行下 hexo new post “1web log”新建一个md文档在我的 电脑的目录下 F:\\hexo\\source\\ _posts 将会看到 “1web log.md” 文件,在该md文档里就可以写自己的博客啦！！！ write_blog 6.下载主题在github克隆别人的模板可以在Hexo Themes上面寻找合适的模板，然后克隆下来，并将这个模板文件放到thems文件夹下，将修改_config里面的文件来去配置，然后一些资源文件里面的配置根据自身需要去调整，详细配置详见hexo官方文档。 deploy_step 7.调试开发准备工作都做完了，就可以开启服务去调试啦！！！ hexo g #生成静态页面至public目录hexo s #开启预览访问端口 8.推送代码站点都配置完了，命令行状态下输入 npm install hexo-deployer-git –save 安装插件，(别忘了配置_config里面的deploy)然后编辑好文章 在命令行下输入 hexo d -g 将代码上传到github。 设置关联域名如果想逼格高一点，还可以设置IP去万网申请一个IP地址，很便宜几块钱,如下设置一下，实在不懂请点击新手引导，然后在github对应仓库中（就是*github.io文件）进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去save就OK啦，最后在hexo仓库下新建一个CNAME文件，并将申请的域名填进去保存。 IP IP2 一些常用命令 hexo clean &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#删除public文件夹等一些生产目录下的文件hexo new “postName” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#新建文章hexo new page “pageName” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#新建页面hexo generate &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#生成静态页面至public目录hexo server &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#将.deploy目录部署到GitHubhexo help &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看帮助hexo version &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看Hexo的版本 一些网站或文章标题等配置参数 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 作者名 language 网站语言 timezone 网站使用的时区 url 网站url root 网站根目录","tags":[{"name":"经验","slug":"经验","permalink":"http://spzhanqi.top/tags/经验/"},{"name":"心得","slug":"心得","permalink":"http://spzhanqi.top/tags/心得/"}]}]